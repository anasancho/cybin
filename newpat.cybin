Pat={}
setmetatable(Pat,Pat)
function Pat:__call(t)
  if self==Pat then
    local o={}
    t=t or {}
    for i=1,#t do
      if type(t[i])=='table' then
	o[i]=Pat(t[i])
      else
	o[i]=t[i]
      end
    end
    local mt={}
    for k,v in pairs(self) do mt[k]=v end
    mt.__call=mt.__zindex
    o=setmetatable(o,mt)
    return o
  end
end
function Pat:__zindex(i)
  while i<0 do i=i+#self end
  while i>=#self do i=i-#self end
  return rawget(self,i+1)
end
function Pat:__index(i)
  i=i-1
  while i<0 do i=i+#self end
  while i>=#self do i=i-#self end
  return rawget(self,i+1)
end
function Pat.__combine(a,b,operator)
  local function opwrapper(a,b)
    if a==nil or b==nil then
      return Pat{}
    else
      return operator(a,b)
    end
  end
  local ret=Pat{}
  if type(a)=="table" and type(b)=="table" then
    for i=1,math.max(#a,#b) do ret[i]=opwrapper(a[i],b[i]) end
  elseif type(a)=="number" and type(b)=="table" then
    for i=1,#b do ret[i]=opwrapper(a,b[i]) end
  elseif type(a)=="table" and type(b)=="number" then
    for i=1,#a do ret[i]=opwrapper(a[i],b) end
  end
  return ret
end
function Pat:__tostring()
  local function tprint(t)
    local out='['
    for i=1,#t do
      local separator=' '
      if i==1 then separator='' end
      if type(t[i])=='table' and #t[i]<1 and #t[i].t<1 then
        out=out..separator..'_'
      else
        out=out..separator..tostring(t[i])
      end
    end
    return out..']'
  end
  return tprint(self)
end
function Pat:__concat(pat)
  if pat==nil then return self end
  local ret=Pat(self)
  for i=1,#pat do table.insert(ret,pat[i]) end
  return ret
end
function Pat.__add(a,b)
  return Pat.__combine(a,b,function(a,b) return a+b end)
end
function Pat.__sub(a,b)
  return Pat.__combine(a,b,function(a,b) return a-b end)
end
function Pat.__mul(a,b)
  return Pat.__combine(a,b,function(a,b) return a*b end)
end
function Pat.__div(a,b)
  return Pat.__combine(a,b,function(a,b) return a/b end)
end
function Pat.__mod(a,b)
  return Pat.__combine(a,b,function(a,b) return a%b end)
end
function Pat.__pow(a,b)
  return Pat.__combine(a,b,function(a,b) return a^b end)
end
function Pat.__unm(self)
  return Pat.__combine(0,self,function(a,b) return a-b end)
end
-----------------------------------------------------------
-----------------------------------------------------------
-----------------------------------------------------------
function Pat.dup(n,size)
  local pat=Pat{}
  for i=1,size do pat[i]=n end
  return pat
end
function Pat.e(nPegs,nHoles)
  local pegs,holes,lastPegIndex,work,pegs,holes
  local function genDup(n,size)
    local t={}
    for i=1,size do t[i]=n end
    return t
  end
  local flatten=function(arr)
    local result={}
    local function flatten(arr)
      for _, v in ipairs(arr) do
        if type(v)=="table" then
          flatten(v)
        else
          table.insert(result,v)
        end
      end
    end
    flatten(arr)
    return result
  end
  local function concat(a,b)
    if b==nil then return a end
    local ret={}
    for i=1,#a do ret[#ret+1]=a[i] end
    for i=1,#b do ret[#ret+1]=b[i] end
    return ret
  end
  local function selectRange(t,from,to)
    local ret={}
    for i=from,to,1 do ret[#ret+1]=t[i] end
    return ret
  end
  if nPegs<1 then return Pat.GenDup(0,nHoles) end
  nHoles=nHoles-nPegs
  pegs=genDup({1},nPegs)
  holes=genDup({0},nHoles)
  lastPegIndex=0
  work=function()
    if (lastPegIndex~=0) then
      holes=selectRange(pegs,lastPegIndex,#pegs)
      pegs=selectRange(pegs,1,lastPegIndex-1)
    end
    nPegs=#pegs
    nHoles=#holes
    for inc=0,nHoles-1,1 do
      pegs[(inc%nPegs)+1]=concat(pegs[(inc%nPegs)+1],holes[inc+1])
    end
    lastPegIndex=(nHoles%nPegs)+1
  end
  work()
  while (lastPegIndex~=1) and (lastPegIndex~=(nPegs)) do
    work()
  end
  return Pat(flatten(pegs))
end
