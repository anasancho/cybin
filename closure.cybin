--[[
dofile('closure.cybin')
--]]

time=0

os.execute('jack_connect cybin:audio-out_1 system:playback_1 && jack_connect cybin:audio-out_2 system:playback_2')

function makeCounter(n)
   local c=n or -1
   return function(r)
      c=c+1
      c=r or c
      return c
   end
end

c1 = makeCounter(1)
c2 = makeCounter(1)
c3 = makeCounter(1)
c4 = makeCounter(1)
c5 = makeCounter(1)
c6 = makeCounter(1)
seq = {0,3,5,7,10,7,5,3}

function __process(t)
   local i=c2()
   if i>10000*0.5 then
      c2(0)
      if c3()>#seq then c3(1) end
      c4()
      if math.mod(c4(c4()-1),8)==0 then c5() end
      if math.mod(c4(c4()-1),32)==0 then c6() end
   end
   return math.sin(cybin.time*3.145*(1/4)*math.pow(3,math.mod(c5()*7,5))*55*(math.mod(c1()*7,math.mod(math.mod(c4(c4()-1),23),4+math.mod(c5(c5()-1),2+math.mod(c6(c6()-1),3)))+2)+1)*math.pow(2,(math.mod(c6(c6()-1)*5,12)+seq[c3(c3()-1)])/12))
end

function makeLagger(coef)
   local lastVal=0
   return function(newVal)
      lastVal = lastVal*(1-(coef or 0.01))+newVal*(coef or 0.01)
      return lastVal
   end
end

function makePhase(p)
   local phase=p or 0
   return function(freq)
      phase=phase+(freq/cybin.samplerate)
      return phase
   end
end

lag = makeLagger(0.0002)
ph = makePhase()


function wrapAt(t,i)
   return t[math.mod(i,#t)+1]
end


function __process()
   local out=0
   local freq = math.pow(2,lag(wrapAt({3,-1,0,0,3,-1,0,24},math.floor(cybin.time)))/12)*440
   local phase = ph(freq)
   for i=1,110 do
      out=out+(math.sin(phase*3.145*2*i*math.pow(1.004,i)/8)/i)*math.sin(i/100+cybin.time*0.11)
   end
   for i=1,110 do
      out=out+(math.sin(phase*3.145*2*i*math.pow(1.0001,i)/4)/i)*math.sin(i/73+cybin.time*0.17)
   end
   out = math.atan(out*100)*0.1
   return out,out
end
