require 'cybin'

--[[
dofile('procjazz.cybin')
#######################
generate a heirarchical rhythm
define a target root note + chord
define each preceding roots as a function of the target root
define each chord based on current root + efficient voice leading to target chord/chord ahead
sketch melody over current progression of roots and chords with rules for each heirarchical level
is this music???
#######################
we must be able to
* determine how efficient the voice leading between two chords is
* 
]]--

function Pat:IndicesWhere(f)
   local ret={}
   for i=1,#(self.t or self) do
      if f(self[i]) then ret[#ret+1]=i end
   end
   return ret
end
function Pat:Length()
   return #self.t
end
function Pat:Empty()
   return #self.t==0
end

function Pat:NextNonEmpty(i)
   local offset=i
   while offset < #(self.t or self)*2 do
      offset=offset+1
      local val=self:WrapAt(offset)
      if type(val)~='table' or #(val.t or val)>0 then
	 return (offset-1)%#(self.t or self)+1
      end
   end
   return nil
end
function Pat:PrevNonEmpty(i)
   local offset=i+#(self.t or self)
   while offset > 0 do
      offset=offset-1
      local val=self:WrapAt(offset)
      if type(val)~='table' or #(val.t or val)>0 then
	 return (offset-1)%#(self.t or self)+1
      end
   end
   return nil
end

function Pat.GenerateScale(mode,length,interval,pitches)
   mode=mode or 0
   length=length or 7
   interval=interval or 7
   pitches=12
   local ret=Pat{}
   for i=1,length do ret[i]=(mode+(i-1)*interval)%pitches end
   table.sort(ret.t)
   return ret
end
function Pat:Mindex()
   local mindex=nil
   for i=1,#(self.t or self) do
      if type(self[i]) == 'number' then
	 if mindex==nil then
	    mindex=i
	 elseif self[i]<self[mindex] then mindex=i
	 end
      end
   end
   return mindex
end
function Pat:Closest(x)
   local closeness=P(self):Apply(function(y) return math.abs(y-x) end)
   return self[closeness:Mindex()]
end

heir=P.GenBjorkStructure(48,{32,24,8})
levels=heir:Max()
roots=P.GenDup(P{},#heir.t)
maxLevelLeap=5
levelOffset=0
levelIntervals=P{4,2,1}
for i=levels,1,-1 do
   levelIndices=P(heir:IndicesWhere(function(x) return x==i end))
   for j=1,levelIndices:Length() do
      if i==levels then	 
	 roots[levelIndices[levelIndices:Length()-j+1]]=((j-1)*maxLevelLeap+levelOffset)%12 
      else
	 levelIndex=levelIndices[j]
	 prevVal=roots[roots:PrevNonEmpty(levelIndex)]
	 nextVal=roots[roots:NextNonEmpty(levelIndex)]
	 local dir=0
	 roots[levelIndex]=math.floor((prevVal+nextVal)/2+0.5)
	 print(prevVal,nextVal)
      end
   end
end
roots=roots:Apply(function(x) return P.GenerateScale(0,9):Closest(x) end)
roots=roots:Reverse():NoRepeats():Reverse()
for i=1,#(roots.t or roots) do
   if roots[i]==roots[roots:NextNonEmpty(i)] then roots[roots:NextNonEmpty(i)]=Pat{} end
end

ind=0
s=Poly{voice=Pluck,maxVoices=6}
function play(t)
   if type(roots:WrapAt(ind))=='number' then
      if(heir:WrapAt(ind)>P{2,1,2,1,2}:WrapAt(ind)) then
	 s{freq=P{roots:WrapAt(ind)}:__add(12):EdoPitch2Freq()[1],harmonic=4,coef=-0.95,reso=2,cutoff=2000,durations={0.005,0.9}}
      end
      if heir:WrapAt(ind)<3 then
	 s{freq=P{roots:WrapAt(ind)}:__add(36):EdoPitch2Freq()[1],harmonic=8,reso=2,cutoff=4000,durations={0.01,1}}
      end
      if heir:WrapAt(ind)==2 then
	 for i=0,2 do
	    local freq=P{roots:WrapAt(ind)}:Apply(function(x) return P.GenerateScale(0,9):Closest(x-i*3.5) end):__add(36):EdoPitch2Freq()[1]
	    s{freq=freq,harmonic=4,reso=0.1,filterType='highpass',cutoff=10000,durations={0.01,3},amp=0.3}
	 end
      end
   end
   ind=ind+1
   return 1/8
end
m=Metro()
m('play')

r=Reverb2{}
function __process()
   m:Process()
   local out=s:Process()
   out=r:Process(out)*0.4+out
   out=out*0.1
   return out,out
end
