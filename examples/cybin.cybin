Utils={}
function Utils.scale(x,a,b,na,nb)
  local i=(x-a)/(b-a)
  return na*i+(nb*(1-i))
end
----------------------
----------------------
SinOsc={}
SinOsc.__index=SinOsc
setmetatable(SinOsc, {__call = function (cls, ...) return cls.new(...) end,})
function SinOsc.new()
  local o={}
  setmetatable(o,SinOsc)
  o.phase=0
  o.freq=440
  o.amp=1
  return o
end
function SinOsc:Process(samplerate)
  self.phase=self.phase+(math.pi*2*self.freq/samplerate)
  return math.sin(self.phase)*self.amp;
end
----------------------
----------------------
PulseOsc={}
PulseOsc.__index=PulseOsc
setmetatable(PulseOsc, {__call = function (cls, ...) return cls.new(...) end,})
function PulseOsc.new()
  local o={}
  setmetatable(o,PulseOsc)
  o.phase=0
  o.freq=440
  o.amp=1
  o.width=0.5
  return o
end
function PulseOsc:Process(samplerate)
  self.phase=self.phase+self.freq/samplerate
  while self.phase>1 do self.phase=self.phase-1 end
  if self.phase > self.width then return 1*self.amp else return -1*self.amp end
end
----------------------
----------------------
SawOsc={}
SawOsc.__index=SawOsc
setmetatable(SawOsc, {__call = function (cls, ...) return cls.new(...) end,})
function SawOsc.new()
  local o={}
  setmetatable(o,SawOsc)
  o.phase=0
  o.freq=440
  o.amp=1
  return o
end
function SawOsc:Process(samplerate)
  self.phase=self.phase+self.freq/samplerate
  while self.phase>1 do self.phase=self.phase-1 end
  return (self.phase*2-1)*self.amp
end
----------------------
----------------------
TriOsc={}
TriOsc.__index=TriOsc
setmetatable(TriOsc, {__call = function (cls, ...) return cls.new(...) end,})
function TriOsc.new()
  local o={}
  setmetatable(o,TriOsc)
  o.phase=0
  o.freq=440
  o.amp=1
  return o
end
function TriOsc:Process(samplerate)
  self.phase=self.phase+self.freq/samplerate
  while self.phase>1 do self.phase=self.phase-1 end
  return (math.abs(self.phase-0.5)*4-1)*self.amp
end
----------------------
----------------------
Line={}
Line.__index = Line
setmetatable(Line, {__call = function (cls, ...) return cls.new(...) end,})
function Line.new()
  local o={}
  setmetatable(o,Line)
  o.from=1
  o.to=0
  o.duration=1
  o.delta=-1
  return o
end
function Line:Process(samplerate)
  local output=0
  if self.delta>-1 then
    output=self.to*self.delta/self.duration + self.from*(self.duration-self.delta)/self.duration
    self.delta=self.delta+1/samplerate
    if self.delta>self.duration+1/samplerate then self.delta = -1 end
  else
    output=self.to
  end
  return output
end
function Line:Reset()
  self.delta=0
end
----------------------
----------------------
Filter={}
Filter.__index=Filter
setmetatable(Filter, {__call = function (cls, ...) return cls.new(...) end,})
function Filter.new(filterType)
  local o={}
  setmetatable(o,Filter)
  filterType="lowpass"
  o.a0=1
  o.a1=0
  o.a2=0
  o.b1=0
  o.b2=0
  o.Fc=0.25
  o.Q=0.7
  o.peakGain=0
  o.z1=0
  o.z2=0
  o.filterType=filterType
  o:SetType(o.filterType)
  return o
end
function Filter:CalcBiquad()
  local norm
  local V=math.pow(10,math.abs(self.peakGain)/20)
  local K=math.tan(math.pi*self.Fc)
  if self.filterType=="lowpass" then
    norm = 1 / (1 + K / self.Q + K * K)
    self.a0 = K * K * norm
    self.a1 = 2 * self.a0
    self.a2 = self.a0
    self.b1 = 2 * (K * K - 1) * norm
    self.b2 = (1 - K / self.Q + K * K) * norm
  end
  if self.filterType=="highpass" then
    norm = 1 / (1 + K / self.Q + K * K);
    self.a0 = 1 * norm;
    self.a1 = -2 * self.a0;
    self.a2 = self.a0;
    self.b1 = 2 * (K * K - 1) * norm;
    self.b2 = (1 - K / self.Q + K * K) * norm;
  end
  if self.filterType=="bandpass" then
    norm = 1 / (1 + K / self.Q + K * K);
    self.a0 = K / self.Q * norm;
    self.a1 = 0;
    self.a2 = -self.a0;
    self.b1 = 2 * (K * K - 1) * norm;
    self.b2 = (1 - K / self.Q + K * K) * norm;
  end
  if self.filterType=="notch" then
    norm = 1 / (1 + K / self.Q + K * K);
    self.a0 = (1 + K * K) * norm;
    self.a1 = 2 * (K * K - 1) * norm;
    self.a2 = self.a0;
    self.b1 = self.a1;
    self.b2 = (1 - K / self.Q + K * K) * norm;
  end
  if self.filterType=="peak" then
    if self.peakGain >= 0 then
      norm = 1 / (1 + 1/self.Q * K + K * K);
      self.a0 = (1 + V/self.Q * K + K * K) * norm;
      self.a1 = 2 * (K * K - 1) * norm;
      self.a2 = (1 - V/self.Q * K + K * K) * norm;
      self.b1 = self.a1;
      self.b2 = (1 - 1/self.Q * K + K * K) * norm;
    else
      norm = 1 / (1 + V/self.Q * K + K * K);
      self.a0 = (1 + 1/self.Q * K + K * K) * norm;
      self.a1 = 2 * (K * K - 1) * norm;
      self.a2 = (1 - 1/self.Q * K + K * K) * norm;
      self.b1 = self.a1;
      self.b2 = (1 - V/self.Q * K + K * K) * norm;
    end
  end
  if self.filterType=="lowshelf" then
    if self.peakGain >= 0 then
      norm = 1 / (1 + math.sqrt(2) * K + K * K);
      self.a0 = (1 + math.sqrt(2*V) * K + V * K * K) * norm;
      self.a1 = 2 * (V * K * K - 1) * norm;
      self.a2 = (1 - math.sqrt(2*V) * K + V * K * K) * norm;
      self.b1 = 2 * (K * K - 1) * norm;
      self.b2 = (1 - math.sqrt(2) * K + K * K) * norm;
    else
      norm = 1 / (1 + math.sqrt(2*V) * K + V * K * K);
      self.a0 = (1 + math.sqrt(2) * K + K * K) * norm;
      self.a1 = 2 * (K * K - 1) * norm;
      self.a2 = (1 - math.sqrt(2) * K + K * K) * norm;
      self.b1 = 2 * (V * K * K - 1) * norm;
      self.b2 = (1 - math.sqrt(2*V) * K + V * K * K) * norm;
    end
  end
  if self.filterType=="highshelf" then
    if self.peakGain >= 0 then
      norm = 1 / (1 + math.sqrt(2) * K + K * K);
      self.a0 = (V + math.sqrt(2*V) * K + K * K) * norm;
      self.a1 = 2 * (K * K - V) * norm;
      self.a2 = (V - math.sqrt(2*V) * K + K * K) * norm;
      self.b1 = 2 * (K * K - 1) * norm;
      self.b2 = (1 - math.sqrt(2) * K + K * K) * norm;
    else
      norm = 1 / (V + math.sqrt(2*V) * K + K * K);
      self.a0 = (1 + math.sqrt(2) * K + K * K) * norm;
      self.a1 = 2 * (K * K - 1) * norm;
      self.a2 = (1 - math.sqrt(2) * K + K * K) * norm;
      self.b1 = 2 * (K * K - V) * norm;
      self.b2 = (V - math.sqrt(2*V) * K + K * K) * norm;
    end
  end
end
function Filter:SetType(filterType)
  self.filterType=filterType
  self:CalcBiquad()
end
function Filter:SetFreq(freq,samplerate)
  self.Fc=freq/samplerate
  self:CalcBiquad()
end
function Filter:SetQ(q)
  self.Q=q
  self:CalcBiquad()
end
function Filter:Process(input)
  local output = input * self.a0 + self.z1;
  self.z1 = input * self.a1 + self.z2 - self.b1 * output;
  self.z2 = input * self.a2 - self.b2 * output;
  return output;
end
----------------------
----------------------
Voice={}
Voice.__index=Voice
setmetatable(Voice, {__call = function (cls, ...) return cls.new(...) end,})
function Voice.new()
  local o={}
  setmetatable(o,Voice)
  o.osc=PulseOsc.new()
  o.release=Line.new()
  o.attack=Line.new()
  o.attack.from=0
  o.attack.to=1
  o.attack.duration=0.005
  o.filter=Filter.new("lowpass")
  return o
end
function Voice:PlayNote(note)
  self.osc.freq=440*math.pow(2,(note-69)/12);
  self.attack:Reset()
  self.release:Reset()
end
function Voice:Process(sr)
  local env=self.attack:Process(sr)*self.release:Process(sr)
  local expEnv=math.pow(env,10)
  self.osc.width=Utils.scale(expEnv,0,1,0.1,0.5)
  self.filter:SetFreq(Utils.scale(expEnv,0,1,4000,50),sr)
  return self.filter:Process(self.osc:Process(sr))*env
end
----------------------
----------------------
Synth={}
Synth.__index=Synth
setmetatable(Synth, {__call = function (cls, ...) return cls.new(...) end,})
function Synth.new()
  local o={}
  setmetatable(o,Synth)
  o.numVoices=50
  o.voices={}
  o.voiceIndex=1
  o.filter=Filter.new("lowshelf")
  for i=1,o.numVoices do
    table.insert(o.voices,Voice.new())
  end
  return o
end
function Synth:PlayNote(note)
  self.voices[self.voiceIndex]:PlayNote(note)
  self.voiceIndex=(self.voiceIndex+1)%self.numVoices+1
end
function Synth:Process(sr)
  local output=0
  for i=1,#(self.voices) do
    if self.voices[i].release.delta>-1 then output=output+self.voices[i]:Process(sr) end
  end
  return self.filter:Process(output/self.numVoices)
end
----------------------
----------------------
Metro={}
Metro.__index=Metro
setmetatable(Metro, {__call = function (cls, ...) return cls.new(...) end,})
function Metro.new()
  local o={}
  setmetatable(o,Metro)
  o.events={}
  o.pats={}
  o.time=0
  return o
end
function Metro:Process(sr)
  local rmindices={}
  local now=self.time
  for i=1,#self.events do
    if self.time>self.events[i].start then
      self.events[i].func(self.time)
      table.insert(rmindices,i)
    end
  end
  for i=1,#rmindices do
    table.remove(self.events,rmindices[#rmindices-i+1])
  end
  self.time=self.time+1/sr
  return now
end
function Metro:Pat(pat,handler,interval)
  local function close(value)
    return function(time)
      handler(value,time)
    end
  end
  local events=pat:QueryEvents(self.time,self.time+interval,1)
  for i=1,#events do
    events[i].func=close(events[i].value)
  end
  self:Events(events)
end
function Metro:Event(start,func)
  table.insert(self.events,{start=start,func=func})
end
function Metro:Events(e)
  for i=1,#e do
    table.insert(self.events,e[i])
  end
end
function Metro:Interval(func)
  local callback=nil
  if type(func)=='function' then
    callback=function(time)
      local nextTime=self.time+func(self.time)
      self:Event(nextTime,callback)
    end
  elseif type(func)=='string' and _G[func]~=nil then
    callback=function(time)
      if _G[func]~=nil then
        local nextTime=self.time+_G[func](self.time)
        self:Event(nextTime,callback)
      end
    end
  end
  if callback~=nil then callback() end
end
----------------------
----------------------
Sampler={}
Sampler.__index=Sampler
setmetatable(Sampler, {__call = function (cls, ...) return cls.new(...) end,})
function Sampler.new(s)
  local o={}
  setmetatable(o,Sampler)
  o.sample=s
  o.grainsize=s.samplerate*30/1000
  o.grain1start=0
  o.grain1sindex=0
  o.grain2start=0
  o.grain2sindex=0
  o.grainwindex=0
  o.sindex=1
  o.speed=1
  o.pitch=1
  o.loop=true
  o.grainxfade=1
  o.basenote=60
  return o
end
function Sampler:Note2Pitch(n,sr)
   local scaler=math.pow(2,(n-self.basenote)/12)
   self.pitch=scaler
end
function Sampler:Process(sr)
  local out={}
  for i=1,self.sample.channels do out[i]=0 end
  if self.loop==false and self.sindex>self.sample.frames then
    return unpack(out)
  end
  if self.grainwindex >= self.grainsize then
    self.grainwindex=0
    self.grain1sindex=0
    self.grain1start=self.grain2start+self.grain2sindex
    self.grain2sindex=0
    self.grain2start=self.sindex
  end
  local grain1channels=self:GetChannels(self.grain1sindex+self.grain1start)
  local grain2channels=self:GetChannels(self.grain2sindex+self.grain2start)
  local nofx=self:GetChannels(self.sindex)
  for i=1,self.sample.channels do
    local window1=math.cos(math.pi*0.5*self.grainwindex/self.grainsize)
    local window2=math.sin(math.pi*0.5*self.grainwindex/self.grainsize)
    out[i]=grain1channels[i]*window1+grain2channels[i]*window2
    out[i]=out[i]*self.grainxfade+nofx[i]*(1-self.grainxfade)
  end
  self.grain1sindex=self.grain1sindex+1*self.pitch
  self.grain2sindex=self.grain2sindex+1*self.pitch
  self.grainwindex=self.grainwindex+1
  self.sindex=self.sindex+1*self.speed
  return unpack(out)
end
function Sampler:GetChannels(i)
  if self.loop==false and i>self.sample.frames then
    local out={}
    for i=1,self.sample.channels do out[i]=0 end
    return out
  end
  while i>self.sample.frames do i=i-self.sample.frames end
  while i<1 do i=i+self.sample.frames end
  if i==0 then i=1 end
  local out={}
  for j=1,self.sample.channels do
    out[j]=self.sample[math.floor(i-1)*self.sample.channels+j]
    if out[j]==nil then out[j]=0 end
  end
  return out
end
----------------------
----------------------
Env={}
Env.__index=Env
setmetatable(Env, {__call = function (cls, ...) return cls.new(...) end,})
function Env.new(v,d)
  local o={}
  setmetatable(o,Env)
  o.values=v
  o.durations=d
  o.times={}
  local sum=0
  for i=1,#o.durations do
    o.times[i]=sum
    sum=sum+o.durations[i]
  end
  o.times[#o.durations+1]=sum
  o.delta=-1
  o.out=0
  return o
end
function Env:Process(sr)
  local i=1
  if self.delta==-1 then return self.out end
  if self.delta>=self.times[#self.times] then
    self.delta=-1
    self.out=self.values[#self.values]
    return self.out
  end
  for i=1,#self.durations do
    if self.delta<=self.times[i+1] then
      local interp=(self.delta-self.times[i])/self.durations[i]
      self.out=self.values[i]*(1-interp)+self.values[i+1]*interp
      self.delta=self.delta+(1/sr)
      return self.out
    end
  end
  return self.out
end
----------------------
----------------------
Pat={}
setmetatable(Pat, {__call = function (cls, ...) return cls.new(...) end,})
Pat.__index=function(t,k)
  if type(k)=='number' then
    return t.t[k]
  else
    return Pat[k]
  end
end
Pat.__newindex=function(t,k,v)
  if type(k)=='number' then
    t.t[k]=v
  else
    rawset(t,k,v)
  end
end
function Pat.new(t)
  local o={}
  setmetatable(o,Pat)
  o.t=t.t or {}
  o.cycles=t.cycles or 1
  o.parallel=t.parallel or false
  for i=1,#t do
    if type(t[i])=='table' then
      o.t[i]=Pat(t[i])
    else
      o.t[i]=t[i]
    end
  end
  return o
end
function Pat.GenDup(n,size)
  local pat=Pat{}
  for i=1,size do pat[i]=n end
  return pat
end
function Pat.GenBjork(nPegs,nHoles)
  local pegs,holes,lastPegIndex,work,pegs,holes
  local function genDup(n,size)
    local t={}
    for i=1,size do t[i]=n end
    return t
  end
  local flatten=function(arr)
    local result={}
    local function flatten(arr)
      for _, v in ipairs(arr) do
        if type(v)=="table" then
          flatten(v)
        else
          table.insert(result,v)
        end
      end
    end
    flatten(arr)
    return result
  end
  local function concat(a,b)
    if b==nil then return a end
    local ret={}
    for i=1,#a do ret[#ret+1]=a[i] end
    for i=1,#b do ret[#ret+1]=b[i] end
    return ret
  end
  local function selectRange(t,from,to)
    local ret={}
    for i=from,to,1 do ret[#ret+1]=t[i] end
    return ret
  end
  if nPegs<1 then return Pat.GenDup(0,nHoles) end
  nHoles=nHoles-nPegs
  pegs=genDup({1},nPegs)
  holes=genDup({0},nHoles)
  lastPegIndex=0
  work=function()
    if (lastPegIndex~=0) then
      holes=selectRange(pegs,lastPegIndex,#pegs)
      pegs=selectRange(pegs,1,lastPegIndex-1)
    end
    nPegs=#pegs
    nHoles=#holes
    for inc=0,nHoles-1,1 do
      pegs[(inc%nPegs)+1]=concat(pegs[(inc%nPegs)+1],holes[inc+1])
    end
    lastPegIndex=(nHoles%nPegs)+1
  end
  work()
  while (lastPegIndex~=1) and (lastPegIndex~=(nPegs)) do
    work()
  end
  return Pat.new(flatten(pegs))
end
function Pat.GenBjorkStructure(size,selects)
  local currentLevel=Pat.GenDup(1,size)
  local ret=Pat.GenDup(0,size)
  for i=1,#selects do
    currentLevel=currentLevel:BjorkSelect(selects[i])
    ret=ret+currentLevel
  end
  return ret
end
function Pat:BjorkSelect(select)
  local selectIndex,selectPattern,outPattern
  selectIndex=1
  selectPattern=Pat.GenBjork(select,Pat.Sum(self))
  outPattern=Pat.new(self)
  outPattern.t={}
  for i=1,#self.t do outPattern[i]=self[i] end
  for i=1,#outPattern.t do
    if outPattern[i]>0 then
      outPattern[i]=outPattern[i]*selectPattern[selectIndex]
      selectIndex=selectIndex+1
    end
  end
  return outPattern
end
function Pat:WrapAt(index)
  local len=0
  if self.t==nil then len=#self else len=#self.t end
  local out=self[((index-1)%len)+1]
  if type(out)=='table' then
    return Pat(out)
  else
    return out
  end
end
function Pat:SelectRange(from,to)
  local ret=Pat(self);ret.t={}
  for i=from,to,1 do ret.t[#ret.t+1]=self.t[i] end
  return ret
end
function Pat:Sum()
  local sum=0
  for i=1,#self.t do
    if type(self.t[i])=='table' then
      sum=sum+Pat.Sum(self.t[i])
    else
      sum=sum+self.t[i]
    end
  end
  return sum
end
function Pat.combine(a,b,operator)
  local function opwrapper(a,b)
  if a==nil or b==nil then
      return Pat{}
    else
      return operator(a,b)
    end
  end
  local ret
  if type(a)=='table' then
    ret=Pat(a);ret.t={}
  elseif type(b)=='table' then
    ret=Pat(b);ret.t={}
  else
    ret=Pat{}
  end
  if a==nil or b==nil then
    ret=Pat{}
  elseif type(a)=="table" and type(b)=="table" then
    for i=1,math.max(#a.t,#b.t) do ret[i]=opwrapper(Pat.WrapAt(a,i),Pat.WrapAt(b,i)) end
  elseif type(a)=="number" and type(b)=="table" then
    for i=1,#b.t do ret[i]=opwrapper(a,Pat.WrapAt(b,i)) end
  elseif type(a)=="table" and type(b)=="number" then
    for i=1,#a.t do ret[i]=opwrapper(Pat.WrapAt(a,i),b) end
  end
  return ret
end
function Pat:Substitute(values)
  local ret=Pat(self);ret.t={}
  for i=1,#self.t do ret[i]=Pat.WrapAt(values,self[i]) end
  return ret
end
function Pat:SequencedSubstitute(values)
  local valuesIndices={}
  local ret=Pat(self);ret.t={}
  for i=1,#self.t do
    local indicesIndex=self[i]
    if valuesIndices[indicesIndex]==nil then valuesIndices[indicesIndex]=1 end
    ret[i]=Pat.WrapAt(Pat.WrapAt(values,indicesIndex),valuesIndices[indicesIndex])
    valuesIndices[indicesIndex]=valuesIndices[indicesIndex]+1
  end
  return ret
end
function Pat:Expand(by)
  local ret=Pat(self);ret.t={}
  local retIndex=1
  for i=1,#self.t do
    for j=1,by do
      ret[retIndex]=self[i]
      retIndex=retIndex+1
    end
  end
  return ret
end
function Pat:Replace(a,b)
  local ret=Pat(self);ret.t={}
  for i=1,#self.t do
    ret[i]=self[i]
    if ret[i]==a then ret[i]=b end
  end
  return ret
end
function Pat:Integrate()
  local ret=Pat(self);ret.t={}
  for i=1,#self.t do
    ret[i]=self[i]
    if i>1 then ret[i]=ret[i]+ret[i-1] end
  end
  return ret
end
function Pat:Derive()
  local ret=Pat(self);ret.t={}
  for i=1,#self.t do
    ret[i]=self[i]
    if i>1 then ret[i]=ret[i]-self[i-1] end
  end
  return ret
end
function Pat:QueryEvents(a,b,c)
  if a>b then local temp=b; b=a; a=temp; end
  c=c/self.cycles
  a=a*c;b=b*c
  local out={}
  local span=b-a
  local step=1/#self.t
  local i=0
  local eventOffset=math.ceil(a/step)
  local time=eventOffset*step
  local epsilon=0.000000001 --ensure we don't accidentally get the beginning of the next pat
  if self.parallel then
    for i=1,#self.t do
      local e=self.t[i]
      local start=a
      local stop=b
      if type(e)=='table' then
        local events=e:QueryEvents(start,stop,1)
        for i=1,#events do table.insert(out,events[i]) end
      else
        table.insert(out,{start=start,stop=stop,value=e})
      end
    end
  else
    while time<b do
      local e=self.t[((i+eventOffset)%#self.t)+1]
      local start=time
      local stop=time+step
      if type(e)=='table' then
        -- ...due to rounding errors
        local events=e:QueryEvents(start,stop,1/step-epsilon)
        for i=1,#events do table.insert(out,events[i]) end
      else
        table.insert(out,{start=start,stop=stop,value=e})
      end
      i=i+1
      time=time+step
    end
  end
  for i=1,#out do
    out[i].start=out[i].start/c
    out[i].stop=out[i].stop/c
  end
  return out
end
function Pat:P()
  local ret=Pat(self)
  ret.parallel=true
  return ret
end
function Pat:Slow(x)
  local ret=Pat(self)
  ret.cycles=x
  return ret
end
function Pat:Fast(x)
  local ret=Pat(self)
  ret.cycles=1/x
  return ret
end
function Pat:Apply(f)
  for i=1,#self.t do
    local value=self.t[i]
    if type(value)=='table' then
      self.t[i]=value:Apply(f)
    else
      self.t[i]=f(value)
    end
  end
  return self
end
function Pat:MapValues(f) -- backwards compatibilty
  return self:Apply(f)
end
function Pat:Max(func)
  local ret=self[1]
  for i=1,#self.t do
    if self[i]>ret then ret=self[i] end
  end
  return ret
end
function Pat:Min(func)
  local ret=self[1]
  for i=1,#self.t do
    if self[i]<ret then ret=self[i] end
  end
  return ret
end
function Pat:Normalize(func)
  local ret=Pat.new({})
  local min=self:Min()
  local max=self:Max()
  for i=1,#self.t do
    ret[i]=(self[i]-min)/(max-min)
  end
  return ret
end
function Pat:Degree2Pitch(scale,octaveLength)
   scale = scale or {0,2,3,5,7,8,10}
   octaveLength = octaveLength or 12
   local ret=Pat(self)
   local function helper(degree)
      local octave=math.floor(degree/#scale,1)
      local class=math.fmod(degree,#scale)
      while class<0 do class=class+#scale end
      class=class+1
      return scale[class]+octave*octaveLength
   end
   return ret:Apply(helper)
end
function Pat:EdoPitch2Freq(baseNote,baseFreq,divisions,ratio)
   if divisions==nil then divisions=12 end
   if baseFreq==nil then baseFreq=440 end
   if baseNote==nil then baseNote=57 end
   if ratio==nil then ratio=2 end
   ret=Pat(self)
   local function helper(note)
      return baseFreq*math.pow(ratio,(note-baseNote)/divisions)
   end
   return ret:Apply(helper)   
end
function Pat:PitchCompress(low,high,octaveLength)
   if octaveLength==nil then octaveLength=12 end
   local ret=Pat(self)
   local function helper(pitch)
      while pitch<low do pitch=pitch+octaveLength end
      while pitch>high do pitch=pitch-octaveLength end
      return pitch
   end
   return ret:Apply(helper)
end
function Pat:NoRepeats()
   local ret=Pat(self)
   if #ret.t<2 then return ret end
   for i=2,#ret.t do
      if ret.t[i]==ret.t[i-1] then
	 ret.t[i]=Pat{}
      end
   end
   return ret
end
function Pat:Reverse()
   local ret=Pat(self);ret.t={}
   for i=#self.t,1,-1 do
      ret.t[#ret.t+1]=self[i]
   end
   return ret
end
function Pat:__tostring()
  local function tprint(t)
    local out='['
    for i=1,#t do
      local separator=' '
      if i==1 then separator='' end
      if type(t[i])=='table' and #t[i]<1 and #t[i].t<1 then
        out=out..separator..'.'
      else
        out=out..separator..tostring(t[i])
      end
    end
    return out..']'
  end
  return tprint(self.t)
end
function Pat:__concat(pat)
  if pat==nil then return self end
  local ret=Pat(self);
  for i=1,#pat.t do table.insert(ret.t,pat.t[i]) end
  return ret
end
function Pat.__add(a,b)
  return Pat.combine(a,b,function(a,b) return a+b end)
end
function Pat.__sub(a,b)
  return Pat.combine(a,b,function(a,b) return a-b end)
end
function Pat.__mul(a,b)
  return Pat.combine(a,b,function(a,b) return a*b end)
end
function Pat.__div(a,b)
  return Pat.combine(a,b,function(a,b) return a/b end)
end
function Pat.__mod(a,b)
  return Pat.combine(a,b,function(a,b) return a%b end)
end
function Pat.__pow(a,b)
  return Pat.combine(a,b,function(a,b) return a^b end)
end
function Pat.__unm(self)
  return Pat.combine(0,self,function(a,b) return a-b end)
end
----------------------
----------------------
PolySamplerVoice={}
PolySamplerVoice.__index=PolySamplerVoice
setmetatable(PolySamplerVoice, {__call = function (cls, ...) return cls.new(...) end,})
function PolySamplerVoice.new(sample,params)
  local o={}
  setmetatable(o,PolySamplerVoice)
  o.envValues={0,1,0}
  o.envDurations={0.005,1}
  o.start=0
  for k,v in pairs(params) do o[k]=v end
  o.env=Env(o.envValues,o.envDurations)
  o.env.delta=0
  o.sampler=Sampler(sample)
  o.sampler.loop=false
  o.sampler.sindex=o.start*o.sampler.sample.frames
  return o
end
function PolySamplerVoice:Process(sr)
  if self.env.delta<0 then
    local out={}
    for i=1,self.sampler.sample.channels do out[i]=0 end
    return unpack(out)
  else
    return self.env:Process(sr)*self.sampler:Process(sr)
  end
end
----------------------
----------------------
PolySampler={}
PolySampler.__index=PolySampler
setmetatable(PolySampler, {__call = function (cls, ...) return cls.new(...) end,})
function PolySampler.new(s)
  if type(sample)=='string' then sample=cybin.loadaudiofile(sample) end
  local o={}
  setmetatable(o,PolySampler)
  o.sample=s
  o.voices={}
  return o
end
function PolySampler:SetVoice(voice,key,value)
  if type(voice[key])=='function' then
    voice[key](voice,value)
  elseif voice[key]~=nil then
    voice[key]=value
  elseif type(voice.sampler[key])=='function' then
    voice.sampler[key](voice.sampler,value)
  elseif voice.sampler[key]~=nil then
    voice.sampler[key]=value
  end
end
function PolySampler:SetVoices(key,value)
  for i=1,#self.voices do
    self:SetVoice(self.voices[i],key,value)
  end
end
function PolySampler:Play(p)
  local voice=PolySamplerVoice(self.sample,{})
  for k,v in pairs(p) do
    self:SetVoice(voice,k,v)
  end
  table.insert(self.voices,voice)
end
function PolySampler:Process(sr)
  local out={}
  for i=1,self.sample.channels do out[i]=0 end
  for i=#self.voices,1,-1 do
    if self.voices[i].env.delta<0 then table.remove(self.voices,i) end
  end
  for i=1,#self.voices do
    local val={self.voices[i]:Process(sr)};
    for i=1,#val do
      if out[i]==nil then
        out[i]=val[i]
      else
        out[i]=out[i]+val[i]
      end
    end
  end
  return unpack(out)
end
----------------------
----------------------
Compressor={}
Compressor.__index=Compressor
setmetatable(Compressor, {__call = function (cls, ...) return cls.new(...) end,})
function Compressor.new(threshold,ratio,attack,release,makeup,samplerate)
   local o={}
   setmetatable(o,Compressor)
   o.samplerate=samplerate or 48000
   o.threshold=threshold or -10
   o.ratio=ratio or 2
   o.attack=attack or 0.015
   o.release=release or 0.07
   o.makeup=makeup or 0
   o.lsat=1
   return o
end
function Compressor:Process(input)
   local function lin2db(x) return math.log10(x)*20 end
   local function db2lin(x) return math.pow(10,x/20) end
   local function rectify(x)
      if x>=0 then return x else return 0 end
   end
   local dBaboveThreshold=rectify(lin2db(math.abs(input))-self.threshold)
   local linAboveThreshold=db2lin(dBaboveThreshold)
   local coef=1/(self.release*self.samplerate)
   if linAboveThreshold>self.lsat then coef=1/(self.attack*self.samplerate) end
   self.lsat=math.abs(linAboveThreshold)*coef+self.lsat*(1-coef)
   dBaboveThreshold=lin2db(self.lsat)
   local dBin=lin2db(math.abs(input))
   local signIn=1
   if input<0 then signIn=-1 end
   return db2lin(dBin-dBaboveThreshold+dBaboveThreshold/self.ratio)*db2lin(self.makeup)*signIn
end
----------------------
----------------------
Interp={}
setmetatable(Interp,{__call=function(cls,...) return cls.new(...) end})
function Interp.new(t)
   local o={}
   o.t={}
   for i=1,#t do o.t[i]=t[i] end
   setmetatable(o,Interp)
   return o
end
function Interp:Write(k,v)
   if self.lastIndex==nil or self.lastIndex==k then
      k=math.floor(k)
      while k<=0 do k=k+#self.t end
      while k>#self.t do k=k-#self.t end
      self.t[k]=v
      self.lastIndex=k
   else
      local fwdDistance=k-self.lastIndex
      while fwdDistance<0 do fwdDistance=fwdDistance+#self.t end
      while fwdDistance>#self.t do fwdDistance=fwdDistance-#self.t end
      local bckDistance=self.lastIndex-k
      while bckDistance<0 do bckDistance=bckDistance+#self.t end
      while bckDistance>#self.t do bckDistance=bckDistance-#self.t end
      local from=self.t[self.lastIndex]
      local to=v
      if fwdDistance<bckDistance then
	 for i=0,fwdDistance do
	    local interp=i/fwdDistance
	    self.t[self.lastIndex]=from*(1-interp)+to*interp
	    if i~=fwdDistance then self.lastIndex=self.lastIndex+1 end
	    if self.lastIndex>#self.t then self.lastIndex=self.lastIndex-#self.t end
	 end
      else
	 for i=0,bckDistance do
	    local interp=i/bckDistance
	    self.t[self.lastIndex]=from*(1-interp)+to*interp
	    if i~=bckDistance then self.lastIndex=self.lastIndex-1 end
	    if self.lastIndex<1 then self.lastIndex=self.lastIndex+#self.t end
	 end
      end
   end
end
function Interp:Read(k)
   local int=math.floor(k)
   local frac=math.fmod(k,1)
   while int<=0 do int=int+#self.t end
   while int>#self.t do int=int-#self.t end
   local nextInt=int+1
   if nextInt>#self.t then nextInt=nextInt-#self.t end
   return self.t[int]*(1-frac)+self.t[nextInt]*frac
end
Interp.__index=function(self,k)
   if type(k)=='number' then
      return self:Read(k)
   else
      return Interp[k]
   end
end
Interp.__newindex=function(self,k,v)
   if type(k)=='number' then
      self:Write(k,v)
   else
      rawset(self,k,v)
   end
end
----------------------
----------------------
Allpass={}
Allpass.__index=Allpass
setmetatable(Allpass,{__call=function(cls,...) return cls.new(...) end})
function Allpass.new(samps,coef)
   local o={}
   setmetatable(o,Allpass)
   o.buf={}
   for i=1,samps do o.buf[i]=0 end
   o.buf=Interp(o.buf)
   o.size=samps
   o.coef=coef
   o.index=0
   return o
end
function Allpass:Process(input)
   local output=input*self.coef+self.buf[self.index]
   self.buf[self.index]=input+output*-self.coef
   self.index=self.index+1
   while self.index>self.size do self.index=self.index-self.size end
   return output
end
----------------------
----------------------
Comb={}
Comb.__index=Comb
setmetatable(Comb,{__call=function(cls,...) return cls.new(...) end})
function Comb.new(samps,coef)
   local o={}
   setmetatable(o,Comb)
   o.buf={}
   for i=1,samps do o.buf[i]=0 end
   o.buf=Interp(o.buf)
   o.size=samps
   o.coef=coef
   o.index=0
   return o
end
function Comb:Process(input)
   self.buf[self.index]=input+self.buf[self.index]*self.coef
   local output=self.buf[self.index]
   self.index=self.index+1
   while self.index>self.size do self.index=self.index-self.size end
   return output
end
----------------------
----------------------
Delay={}
Delay.__index=Delay
setmetatable(Delay,{__call=function(cls,...) return cls.new(...) end})
function Delay.new(samps)
   local o={}
   setmetatable(o,Delay)
   o.buf={}
   for i=1,samps do o.buf[i]=0 end
   o.buf=Interp(o.buf)
   o.size=samps
   o.index=0
   return o
end
function Delay:Process(input)
   local output=self.buf[self.index]
   self.buf[self.index]=input
   self.index=self.index+1
   while self.index>self.size do self.index=self.index-self.size end
   return output
end
