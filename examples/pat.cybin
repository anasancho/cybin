require 'cybin'
require 'seq'

Pat={}
Pat.__index=Pat
function Pat.new(t)
   local o={}
   setmetatable(o,Pat)
   o.t={}
   for i=1,#t do o.t[i]=t[i] end
   return o
end

function round(x) if math.fmod(x,1)>=0.5 then
      return math.ceil(x) else return math.floor(x)
end end
function Pat:queryEvents(a,b,c)
   if a>b then local temp=b; b=a; a=temp; end
   a=a*c;b=b*c
   local out={}
   local span=b-a
   local time=a
   local step=1/#self.t
   local i=0
   local eventOffset=math.floor(a/step)
   while time<b do
      local e=self.t[((i+eventOffset)%#self.t)+1]
      local start=a+i/#self.t
      local stop=a+(i+1)/#self.t
      if type(e)=='table' then
	 local events=e:queryEvents(start,stop,1/step)
	 for i=1,#events do table.insert(out,events[i]) end
      else
	 table.insert(out,{start=start,stop=stop,value=e})
      end
      i=i+1
      time=time+step
   end
   local oldOut=out
   out={}
   for i=1,#oldOut do
      if oldOut[i].start>=a and oldOut[i].start<b then
	 out[i]={start=oldOut[i].start/c,stop=oldOut[i].stop/c,value=oldOut[i].value}
      end
   end
   return out
end

--[[
p=Pat.new({0,1,2,3})
e=p:queryEvents(0,0.125,0.5)
table.printr(e)
--]]


function Pat:__tostring()
   local function tprint(t)
      local out='['
      for i=1,#t do
	 local separator=' '
	 if i==1 then separator='' end
	 out=out..separator..tostring(t[i])
      end
      return out..']'
   end
   return tprint(self.t)
end

function table.printr(t)
   local function tprint(t)
      local i=1
      local out='{'
      for k,v in pairs(t) do
	 local separator=', '
	 if i==1 then separator='' end
	 local element=v
	 if type(element)=='table' then
	    element=tprint(element)
	 else
	    element=k..':'..tostring(element)
	 end
	 out=out..separator..element
	 i=i+1
      end
      return out..'}'
   end
   print(tprint(t))
end
function table.map(t,f)
   local o={}
   for i=1,#t do table.insert(o,f(t[i])) end
   return o
end

function close(val,func)
   return function()
      return func(val)
   end
end
function e2f(e)
   local function pn(x)
      --print(x)
      s:PlayNote(60+x)
   end
   return {start=e.start,func=close(e.value,pn)}
end

m=Metro.new()
s=Synth.new()

function table.wrap(t,i)
   while i<#t do i=i+#t end
   return t[(i-1)%#t+1]
end
function play(time)
   local interval=4
   p=Pat.new({0,3,7,Pat.new({0,3,7,12})})
   local events=p:queryEvents(time,time+interval,1)
   events=table.map(events,function(x) return {start=x.start,value=x.value} end)
   events=table.map(events,e2f)
   m:Events(events)
   return interval
end
function trec(time)
   if play~=nil then
      m:Event(m.time+play(time),trec)
   end
end

m:Event(math.ceil(m.time),trec)

function __process(sr)
   m:Process(sr)
   return s:Process(sr)
end

