math.mod=math.fmod
package.path = package.path .. ";../cylibs/?.cybin"
require('clodule').load()
require('utils').load()
if not cybin.offline then
  os.execute('jack_connect cybin:audio-out_1 system:playback_1')
  os.execute('jack_connect cybin:audio-out_2 system:playback_2')
end
function Interpolator()
  function wrap0(t,i) while i<0 do i=i+#t end; while i>=#t do i=i-#t end; return t[i+1] end
  function linterp(t,i,backwards)
    local whole,frac=math.modf(i)
    local current=wrap0(t,whole)
    local target=wrap0(t,whole+1)
    if backwards~=nil then target=wrap(t,whole-1); frac=1+frac end
    return current*(1-frac)+target*(frac)
  end
  return function(t,i)
    return linterp(t,i)
  end
end

function Sin(e)
  e=DC(e) or {}
  if SIN_LUT==nil then
    local LUT={}
    _G['SIN_LUT']=LUT
    for i=1,cybin.samplerate do LUT[#LUT+1]=math.sin(math.pi*2*(i-1)/cybin.samplerate) end
  end
  e.lut=SIN_LUT
  e.freq=e.freq or 440
  e.amp=e.amp or 1
  e.delta=e.delta or 0
  e.terp=Interpolator()
  return function(p)
    if type(p)=='table' then return DC(p,e) end
    phase=p or 0
    e.delta=e.delta+e.freq/cybin.samplerate
    while e.delta>1 do e.delta=e.delta-1 end
    while e.delta<0 do e.delta=e.delta+1 end
    return e.terp(e.lut,(e.delta+phase)*#e.lut)*e.amp
  end
end

function Adsynth(e)
  e=DC(e) or {}
  e.oscs=e.oscs or {}
  e.freq=e.freq or 440
  e.amp=e.amp or 1
  e.env=Env{vals={0,1,1,0},durs={0.001,2,0.001}}
  for i=1,30 do e.oscs[#e.oscs+1]=Sin{
      freq=i*e.freq+math.sin(i*23.173)*e.freq/45,
      amp=e.amp*0.5/i} end
  e.done=false
  return function(p)
    if type(p)=='table' then return DC(p,e) end
    local out=0
    for i=1,#e.oscs do out=out+e.oscs[i]()*(math.cos(i*math.pi*2/80+cybin.time*math.pow(math.mod(e.freq,7.311),2))+1) end
    out=out*e.env()*e.amp
    e.done=e.env{}.done
    return out
  end
end

--[[
dofile('harmor_style_growl_bass.cybin')
--]]

p=Poly()
t=Trigger()

local lastSample=0
function __process()
  t(math.mod(cybin.time*0.5,1),function()
      local freq=math.pow(2,math.mod(math.floor(cybin.time/2)*5,12)/12)*50
      p(Adsynth{freq=freq,amp=1})
      p(Adsynth{freq=freq*3.02,amp=1/3})
      p(Adsynth{freq=freq*5.98,amp=1/3})
  end);
  local out=p()
  out=math.atan(out*1)
  out=out*0.5
  --- simple crossover filter ---
  local coef=0.5+math.sin(cybin.time*2.5+math.pi/8)*0.499
  local lows=out
  lows=lows*coef+(1-coef)*lastSample
  local highs=out-lows
  lastSample=lows
  --- neat little distortion pipeline ---
  out=math.atan(highs*10)+math.atan(lows*10)
  out=math.atan(out*5)/10
  return out,out
end
